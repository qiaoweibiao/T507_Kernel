
/*
 * Copyright (c) 2007-2017 Allwinnertech Co., Ltd.
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */

#define _NCFB0_C_

#include "../nand_physic_inc.h"

#define NDFC_PAGE_TAB_MAGIC "BT0.NTAB"
#define NDFC_PAGE_TAB_HEAD_SIZE (64)
#define STAMP_VALUE 0x5F0A6C39

int small_nand_seed; // small nand random seed flag

typedef struct _Boot_file_head {
	__u32 jump_instruction; // one intruction jumping to real code
	__u8 magic[8];	// ="eGON.BT0" or "eGON.BT1",  not C-style string.
	__u32 check_sum;      // generated by PC
	__u32 length;	 // generated by PC
	__u32 pub_head_size;  // the size of boot_file_head_t
	__u8 pub_head_vsn[4]; // the version of boot_file_head_t
	__u8 file_head_vsn[4]; // the version of boot0_file_head_t or
			       // boot1_file_head_t
	__u8 Boot_vsn[4];      // Boot version
	__u8 eGON_vsn[4];      // eGON version
	__u8 platform[8];      // platform information
} boot_file_head_t;

u32 _cal_sum(u32 *mem_base, u32 size)
{
	u32 count, sum;
	u32 *buf;

	count = size >> 2;
	sum = 0;
	buf = (__u32 *)mem_base;
	do {
		sum += *buf++;
		sum += *buf++;
		sum += *buf++;
		sum += *buf++;
	} while ((count -= 4) > (4 - 1));

	while (count-- > 0)
		sum += *buf++;

	return sum;
}

__s32 check_sum(__u32 *mem_base, __u32 size)
{
	__u32 *buf;
	__u32 count;
	__u32 src_sum;
	__u32 sum;
	boot_file_head_t *bfh;

	bfh = (boot_file_head_t *)mem_base;

	/* generate check sum */
	src_sum = bfh->check_sum; // get check_sum field from the head of boot0;
	bfh->check_sum = STAMP_VALUE; // replace the check_sum field of the
				      // boot0 head with STAMP_VALUE

	count = size >> 2; // unit, 4byte
	sum = 0;
	buf = (__u32 *)mem_base;
	do {
		sum += *buf++; // calculate check sum
		sum += *buf++;
		sum += *buf++;
		sum += *buf++;
	} while ((count -= 4) > (4 - 1));

	while (count-- > 0)
		sum += *buf++;

	bfh->check_sum =
	    src_sum; // restore the check_sum field of the boot0 head

	// msg("sum:0x%x - src_sum:0x%x\n", sum, src_sum);
	if (sum == src_sum)
		return 0; // ok
	else
		return 1; // err
}

int _generate_page_map_tab(__u32 nand_page_size, __u32 copy_cnt, __u32 page_cnt,
			   __u32 *page_addr, __u32 *page_map_tab_addr,
			   __u32 *tab_size)
{
	s32 i, j;
	u32 max_page_cnt;
	u32 checksum = 0;
	u8 *magic = (u8 *)NDFC_PAGE_TAB_MAGIC;
	u32 *pdst = (u32 *)page_map_tab_addr;
	boot_file_head_t *bfh = (boot_file_head_t *)page_map_tab_addr;
	u32 page_tab_size;
	u32 nand_page_cnt;
	u32 c, p;

	if (copy_cnt == 1) {
		if (nand_page_size != 1024) {
			PHY_ERR(
			    "_cal_page_map_tab, wrong @nand_page_size, %d\n",
			    nand_page_size);
			return -1;
		}

		max_page_cnt = (1024 - NDFC_PAGE_TAB_HEAD_SIZE) / 4;
		if (page_cnt > max_page_cnt) {
			PHY_ERR("_cal_page_map_tab, wrong @page_cnt, %d\n",
				page_cnt);
			return -1;
		}

		// clear to 0x00
		for (i = 0; i < 1024 / 4; i++)
			*(pdst + i) = 0x0;

		// set page address
		for (j = 0, i = NDFC_PAGE_TAB_HEAD_SIZE / 4; j < page_cnt;
		     i++, j++)
			*(pdst + i) = page_addr[j];

		// set page table information
		bfh->platform[0] = page_cnt; // entry_cnt
		bfh->platform[1] = 1;	// entry_cell_cnt
		bfh->platform[2] = 4;	// entry_cell_size, byte

		// set magic
		// msg("page map table magic: ");
		for (i = 0; i < sizeof(bfh->magic); i++) {
			bfh->magic[i] = *(magic + i);
			// msg("%c", bfh->magic[i]);
		}
		// msg("\n");

		// set stamp value
		bfh->check_sum = STAMP_VALUE;

		// cal checksum
		checksum = _cal_sum((u32 *)page_map_tab_addr, 1024);
		bfh->check_sum = checksum;

		// check
		if (check_sum((__u32 *)page_map_tab_addr, 1024)) {
			PHY_ERR("_cal_page_map_tab, checksum error!\n");
			return -1;
		}

		*tab_size = 1024;

	} else {

		page_tab_size =
		    NDFC_PAGE_TAB_HEAD_SIZE + copy_cnt * page_cnt * 4;
		if (page_tab_size % nand_page_size)
			nand_page_cnt = page_tab_size / nand_page_size + 1;
		else
			nand_page_cnt = page_tab_size / nand_page_size;
		page_tab_size = nand_page_cnt * nand_page_size;

		/* clear page table memory spare */
		for (i = 0; i < page_tab_size / 4; i++)
			*(pdst + i) = 0x0;

		/* set header */
		bfh->length = page_tab_size;
		bfh->platform[0] = page_cnt; // entry_cnt
		bfh->platform[1] = copy_cnt; // entry_cell_cnt
		bfh->platform[2] = 4;	// entry_cell_size, byte
		bfh->platform[3] = nand_page_size / 512;
		// PHY_DBG("length: 0x%x, page_cnt: %d, copy: %d, cell_size: %d
		// Byte\n",bfh->length, bfh->platform[0], bfh->platform[1],
		// bfh->platform[2]);

		/* fill page address */
		for (p = 0; p < page_cnt; p++) {
			for (c = 0; c < copy_cnt; c++) {
				i = NDFC_PAGE_TAB_HEAD_SIZE / 4 + p * copy_cnt +
				    c;
				j = c * page_cnt + p; // j = c*(page_cnt+4) + p;
				*(pdst + i) = page_addr[j];
			}
		}

		/* set magic */
		// msg("page map table magic: ");
		for (i = 0; i < sizeof(bfh->magic); i++) {
			bfh->magic[i] = *(magic + i);
			// msg("%c", bfh->magic[i]);
		}
		// msg("\n");

		/* set stamp value */
		bfh->check_sum = STAMP_VALUE;

		/* cal checksum */
		checksum = _cal_sum((u32 *)page_map_tab_addr, page_tab_size);
		bfh->check_sum = checksum;
		// msg("bfh->check_sum: 0x%x\n", bfh->check_sum);

		/* check */
		if (check_sum((__u32 *)page_map_tab_addr, page_tab_size)) {
			PHY_ERR("_cal_page_map_tab, checksum error!\n");
			return -1;
		}

		*tab_size = page_tab_size;
	}

	return 0;
}

#define NDFC_RR_TAB_MAGIC "BT0.RRTB"
#define NDFC_DMY_TAB_MAGIC "BT0.DMTB" // dummy table

int _get_read_retry_table(struct _nand_chip_info *nci, u8 *rr_tab)
{
	boot_file_head_t rr_tab_head = {0};
	u32 checksum = 0;
	u8 *magic = NDFC_RR_TAB_MAGIC;
	u8 *dummy_magic = NDFC_DMY_TAB_MAGIC;
	u8 *pdst = (u8 *)rr_tab;
	boot_file_head_t *bfh = (boot_file_head_t *)rr_tab;
	__u32 table_size = sizeof(boot_file_head_t);
	int i;
	// get read retry cmd data

	/* clear page table memory spare */
	for (i = 0; i < table_size; i++)
		*(pdst + i) = 0x0;

	/* set header */
	bfh->length = table_size;
	bfh->platform[3] = nci->sector_cnt_per_page;
	PHY_ERR("length: 0x%x\n", bfh->length);

	/* set magic */
	PHY_ERR("rr table magic: ");
	{
		for (i = 0; i < sizeof(bfh->magic); i++) {
			bfh->magic[i] = *(dummy_magic + i);
			PHY_ERR("%c", bfh->magic[i]);
		}
		PHY_ERR("\n");
	}
	/* set stamp value */
	bfh->check_sum = STAMP_VALUE;

	/* cal checksum */
	checksum = _cal_sum((u32 *)rr_tab, table_size);
	bfh->check_sum = checksum;
	PHY_ERR("bfh->check_sum: 0x%x\n", bfh->check_sum);

	/* check */
	if (check_sum((u32 *)rr_tab, table_size)) {
		PHY_ERR("_cal_rr_tab, checksum error!\n");
		return -1;
	}
}

int m0_write_boot0_one_pagetab_4k(unsigned char *buf, unsigned int len,
				  unsigned int counter)
{
	__u32 i, k, j, count, block;
	__u8 oob_buf[64];
	__u32 tab_size, data_size_per_page;
	__u32 pages_per_block, copies_per_block;
	__u32 page_addr;
	__u32 *pos_data = NULL, *tab = NULL, *rr_tab = NULL;
	int ret;
	struct _nand_chip_info *nci;
	struct _nand_physic_op_par lnpo;

	nci = g_nctri->nci;

#if 0
	/*A50 FPGA LDPC encode have bug, must to use SDR interface By zzm*/
	if (nci->support_toggle_only) {
		ret = before_update_nctri_interface(nci->nctri);
		if (ret) {
			PHY_ERR("before_update nctri nand interface fail!\n");
			return ret;
		}
	} else {
		ret = update_boot0_nctri_interface(nci->nctri);
		if (ret) {
			PHY_ERR("update boot0 nctri nand interface fail!\n");
			return ret;
		}
	}
#endif

	nci->nctri->channel_sel = 1;

	PHY_DBG("burn_boot0_lsb_pagetab_4k mode!\n");

	pos_data = (__u32 *)MALLOC(128 * 4 * BOOT0_MAX_COPY_CNT);
	if (!pos_data) {
		PHY_ERR(
		    "burn_boot0_lsb_FF_mode, malloc for pos_data failed.\n");
		goto error;
	}

	tab = (__u32 *)MALLOC(8 * 1024);
	if (!tab) {
		PHY_ERR("burn_boot0_lsb_FF_mode, malloc for tab failed.\n");
		goto error;
	}

	rr_tab = (__u32 *)MALLOC(8 * 1024);
	if (!rr_tab) {
		PHY_ERR(" malloc for rr tab failed.\n");
		goto error;
	}

	for (i = 0; i < 64; i++)
		oob_buf[i] = 0xff;

	/* get nand driver version */
	nand_get_version(oob_buf);
	if ((oob_buf[0] != 0xff) || (oob_buf[1] != 0x00)) {
		PHY_ERR("get flash driver version error!");
		goto error;
	}

	data_size_per_page = 4096;
	pages_per_block = nci->page_cnt_per_blk;
	copies_per_block = pages_per_block / NAND_BOOT0_PAGE_CNT_PER_COPY_2;

	count = 0;
	for (i = NAND_BOOT0_BLK_START;
	     i < (NAND_BOOT0_BLK_START + aw_nand_info.boot->uboot_start_block);
	     i++) {
		for (j = 0; j < copies_per_block; j++) {
			for (k = 8; k < NAND_BOOT0_PAGE_CNT_PER_COPY_2; k++) {
				page_addr = i * pages_per_block +
					    j * NAND_BOOT0_PAGE_CNT_PER_COPY_2 +
					    k;
				if (nci->is_lsb_page(
					(page_addr % pages_per_block))) {
					*((__u32 *)pos_data + count) =
					    page_addr;
					count++;
					if (((count %
					      (len / data_size_per_page)) ==
					     0) &&
					    (count != 0))
						break;
				}
			}
		}
	}

	_generate_page_map_tab(
	    data_size_per_page,
	    copies_per_block * aw_nand_info.boot->uboot_start_block,
	    len / data_size_per_page, pos_data, tab, &tab_size);

	// get read retry table
	_get_read_retry_table(nci, (u8 *)rr_tab);

	block = NAND_BOOT0_BLK_START + counter;

	PHY_DBG("pagetab boot0 %x \n", block);

	lnpo.chip = 0;
	lnpo.block = block;
	lnpo.page = 0;
	nand_wait_all_rb_ready();

	ret = nci->nand_physic_erase_block(&lnpo);
	if (ret) {
		PHY_ERR("Fail in erasing block %d!\n", lnpo.block);
		// return ret;
	}

	for (j = 0; j < copies_per_block; j++) {
		count = 0;
		for (k = 0; k < NAND_BOOT0_PAGE_CNT_PER_COPY_2; k++) {
			lnpo.chip = 0;
			lnpo.block = block;
			lnpo.page = j * NAND_BOOT0_PAGE_CNT_PER_COPY_2 + k;
			lnpo.sdata = oob_buf;
			lnpo.slen = 64;

			if (nci->is_lsb_page(lnpo.page)) {
				if (k < 4)
					lnpo.mdata = (__u8 *)rr_tab;
				else if (k < 8)
					lnpo.mdata = (__u8 *)tab;
				else {
					lnpo.mdata =
					    (__u8 *)(buf +
						     count *
							 data_size_per_page);
					count++;
				}

				nand_wait_all_rb_ready();
				if (nci->nand_write_boot0_page(nci, &lnpo) !=
				    0) {
					PHY_ERR("Warning. Fail in writing page "
						"%d in block %d.\n",
						lnpo.page, lnpo.block);
				}
				if (count ==
				    (len + data_size_per_page - 1) /
					data_size_per_page) {
					count = 0;
				}
			}
		}
	}
	nci->nctri->channel_sel = 0;
	ndfc_channel_select(nci->nctri, 0);

	if (pos_data)
		FREE(pos_data, 128 * 4 * BOOT0_MAX_COPY_CNT);
	if (tab)
		FREE(tab, 8 * 1024);
	if (rr_tab)
		FREE(rr_tab, 8 * 1024);
	//	if(data_FF_buf)
	//		FREE(data_FF_buf,18048);
	return 0;

error:
	if (pos_data)
		FREE(pos_data, 128 * 4 * BOOT0_MAX_COPY_CNT);
	if (tab)
		FREE(tab, 8 * 1024);
	if (rr_tab)
		FREE(rr_tab, 8 * 1024);
	//	if(data_FF_buf)
	//		FREE(data_FF_buf,18048);
	return -1;
}

int m0_write_boot0_one_1k_mode(unsigned char *buf, unsigned int len,
			       unsigned int counter)
{
	__u32 i, j;
	__u8 oob_buf[64];
	__u32 pages_per_block, blocks_per_copy, start_block, count;
	int ret;
	struct _nand_chip_info *nci;
	struct _nand_physic_op_par lnpo;

	nci = g_nctri->nci;
	nci->nctri->channel_sel = 0;

	PHY_DBG("burn_boot0_1k mode!\n");

	for (i = 0; i < 64; i++)
		oob_buf[i] = 0xff;

	/* get nand driver version */
	nand_get_version(oob_buf);
	if ((oob_buf[0] != 0xff) || (oob_buf[1] != 0x00)) {
		PHY_ERR("get flash driver version error!");
		goto error;
	}

	pages_per_block = nci->page_cnt_per_blk;

	blocks_per_copy = NAND_BOOT0_PAGE_CNT_PER_COPY_4 / pages_per_block;
	if (NAND_BOOT0_PAGE_CNT_PER_COPY_4 % pages_per_block)
		blocks_per_copy++;

	start_block = blocks_per_copy * counter;
	if ((start_block + blocks_per_copy) >
	    aw_nand_info.boot->uboot_start_block) {
		return 0;
	}

	PHY_DBG("boot0 count %d!\n", counter);

	count = 0;
	for (i = start_block; i < (start_block + blocks_per_copy); i++) {
		lnpo.chip = 0;
		lnpo.block = i;
		lnpo.page = 0;
		nand_wait_all_rb_ready();

		ret = nci->nand_physic_erase_block(&lnpo);
		if (ret) {
			PHY_ERR("Fail in erasing block %d!\n", lnpo.block);
			// return ret;
		}

		for (j = 0; j < pages_per_block; j++) {
			lnpo.page = j;
			lnpo.sdata = oob_buf;
			lnpo.slen = 64;
			small_nand_seed = count; // zzm 20180301

			lnpo.mdata = (__u8 *)(buf + 1024 * count);

			nand_wait_all_rb_ready();
			if (nci->nand_write_boot0_page(nci, &lnpo) != 0) {
				PHY_ERR("Warning. Fail in writing page %d in "
					"block %d.\n",
					lnpo.page, lnpo.block);
			}
			count++;
			if (count == len / 1024) {
				count = 0;
			}
		}
	}
	small_nand_seed = 0;

	return 0;

error:

	return -1;
}

int m0_write_boot0_one(unsigned char *buf, unsigned int len,
		       unsigned int counter)
{
	struct _nand_chip_info *nci;
	__u32 pagesize = 0;
	__u32 pagesperblock = 0;

	nci = g_nctri->nci;
	pagesize = nci->sector_cnt_per_page << 9;
	pagesperblock = nci->page_cnt_per_blk;

	PHY_DBG("m0 write boot0 one \n");
	if ((pagesize >= 8192) && (pagesperblock >= 128))
		return m0_write_boot0_one_pagetab_4k(buf, len, counter);
	else
		return m0_write_boot0_one_1k_mode(buf, len, counter);

	return -1;
}
